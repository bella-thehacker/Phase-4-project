import u from "axios";
import { debounce as b, has as h, includes as p, set as l, cloneDeep as e } from "lodash";
import { reactive as C } from "vue";
function T(s = {}, r = new FormData(), t = null) {
  for (const [n, c] of Object.entries(s))
    _(r, O(t, n), c);
  return r;
}
function O(s, r) {
  return s ? `${s}[${r}]` : r;
}
function _(s, r, t) {
  switch (!0) {
    case Array.isArray(t):
      t.forEach((n, c) => _(s, O(r, c.toString()), n));
      break;
    case t instanceof Date:
      s.append(r, t.toISOString());
      break;
    case t instanceof File:
      s.append(r, t, t.name);
      break;
    case t instanceof Blob:
      s.append(r, t);
      break;
    case typeof t == "boolean":
      s.append(r, t ? "1" : "0");
      break;
    case (typeof t == "string" || typeof t == "number"):
      s.append(r, t.toString());
      break;
    case t == null:
      s.append(r, "");
      break;
    case typeof t == "object":
      T(t, s, r);
      break;
    default:
      throw new TypeError(`Unsupported value type: ${typeof t} for key: ${r}`);
  }
}
function S(s) {
  if (s instanceof File || s instanceof Blob)
    return !0;
  if (s instanceof FileList)
    return s.length > 0;
  if (s instanceof FormData) {
    for (const [, r] of s.entries())
      if (S(r))
        return !0;
    return !1;
  }
  if (typeof s == "object" && s !== null) {
    for (const r of Object.values(s))
      if (S(r))
        return !0;
    return !1;
  }
  return !1;
}
var o;
(function(s) {
  s.OPTIONS = "__options", s.RULES = "rules", s.PAGE = "__page", s.VALIDATE_REQUEST_TYPE = "__validateRequestType", s.DATA = "data", s.DELETE = "delete", s.ERROR_FOR = "errorFor", s.ERRORS_FOR = "errorsFor", s.HAS_ERRORS = "hasErrors", s.INITIAL = "initial", s.IS_DIRTY = "isDirty", s.ON_FAIL = "onFail", s.ON_SUCCESS = "onSuccess", s.PATCH = "patch", s.POST = "post", s.PROCESSING = "processing", s.PUT = "put", s.RECENTLY_SUCCESSFUL = "recentlySuccessful", s.RESET = "reset", s.SUBMIT = "submit", s.SUCCESSFUL = "successful", s.WITH_DATA = "withData", s.WITH_OPTIONS = "withOptions", s.FORM_ERROR = "formError", s.WAS_SUCCESSFUL = "wasSuccessful", s.CANCEL = "cancel", s.TRANSFORM = "transform", s.SET_ERROR = "setError", s.SET_ERRORS = "setErrors", s.CLEAR_ERRORS = "clearErrors", s.SET_DEFAULTS = "setDefaults", s.RESET_FORM = "resetForm", s.SUBMIT_FORM = "submitForm", s.GET = "get", s.POST_FORM = "postForm", s.PUT_FORM = "putForm", s.PATCH_FORM = "patchForm", s.DELETE_FORM = "deleteForm", s.OPTIONS_FORM = "optionsForm", s.MARK_RECENTLY_SUCCESSFUL = "markRecentlySuccessful";
})(o || (o = {}));
const R = [
  o.OPTIONS,
  o.RULES,
  o.PAGE,
  o.VALIDATE_REQUEST_TYPE,
  o.DATA,
  o.DELETE,
  o.ERROR_FOR,
  o.ERRORS_FOR,
  o.HAS_ERRORS,
  o.INITIAL,
  o.IS_DIRTY,
  o.ON_FAIL,
  o.ON_SUCCESS,
  o.PATCH,
  o.POST,
  o.PROCESSING,
  o.PUT,
  o.RECENTLY_SUCCESSFUL,
  o.RESET,
  o.SUBMIT,
  o.SUCCESSFUL,
  o.WITH_DATA,
  o.WITH_OPTIONS,
  o.FORM_ERROR,
  o.WAS_SUCCESSFUL,
  o.CANCEL,
  o.TRANSFORM,
  o.SET_ERROR,
  o.SET_ERRORS,
  o.CLEAR_ERRORS,
  o.SET_DEFAULTS,
  o.RESET_FORM,
  o.SUBMIT_FORM,
  o.GET,
  o.POST_FORM,
  o.PUT_FORM,
  o.PATCH_FORM,
  o.DELETE_FORM,
  o.OPTIONS_FORM,
  o.MARK_RECENTLY_SUCCESSFUL
], A = (s) => {
  if (R.includes(s))
    throw new Error(`The field name "${s}" is reserved and cannot be used in a Form or Errors instance.`);
};
class I {
  /**
   * Create a new form instance.
   * @param {TForm} initialData - The initial form data.
   * @param {AxiosInstance} [axiosInstance=axios] - The Axios instance to use for requests.
   */
  constructor(r, t = u) {
    return this.errors = {}, this.processing = !1, this.progress = null, this.wasSuccessful = !1, this.recentlySuccessful = !1, this.isDirty = !1, this.rules = {}, this.transformCallback = null, this.cancelTokenSource = null, this.timeouts = [], this.debouncedSubmit = b((n, c, i) => this.submit(n, c, i), 300), this.data = r, this.defaults = { ...r }, this.axiosInstance = t, this.createProxy(this);
  }
  /**
   * Create a proxy for the form instance to allow for dynamic property access.
   * @param {Form<TForm>} instance - The form instance.
   * @returns {Form<TForm>} The proxied form instance.
   */
  createProxy(r) {
    return new Proxy(r, {
      get(t, n) {
        if (h(t.data, n))
          return t.data[n];
        const c = Reflect.get(t, n, t);
        if (typeof c == "function")
          return c.bind(t);
        if (h(t, n))
          return t[n];
      },
      set(t, n, c) {
        return Object.prototype.hasOwnProperty.call(t, n) ? (t[n] = c, !0) : (A(n), h(t.data, n) && t.data[n] !== c && !p(R, n) ? (l(t.defaults, n, t.data[n]), l(t.data, n, c), t.isDirty = !0, !0) : h(t, n) ? (t[n] = c, !0) : !1);
      }
    });
  }
  /**
   * Set a specific error for a form field.
   * @param {keyof TForm} field - The form field.
   * @param {string} message - The error message.
   * @returns {void}
   */
  setError(r, t) {
    this.errors[r] = t;
  }
  /**
   * Set multiple errors for the form.
   * @param {Partial<Record<keyof TForm, string>>} errors - The form errors.
   * @returns {void}
   */
  setErrors(r) {
    this.errors = r;
  }
  /**
   * Clear all form errors.
   * @returns {void}
   */
  clearErrors() {
    this.errors = {};
  }
  /**
   * Reset form data to defaults. You can optionally reset specific fields.
   * @param {...(keyof TForm)[]} fields - The fields to reset.
   * @returns {void}
   */
  reset(...r) {
    r.length === 0 ? Object.assign(this.data, e(this.defaults)) : r.forEach((t) => {
      this.data[t] = e(this.defaults[t]);
    }), this.isDirty = !1, this.clearErrors();
  }
  /**
   * Set new default values for the form.
   * @param {keyof TForm | Partial<TForm>} [fieldOrFields] - The field or fields to set as defaults.
   * @param {FormDataConvertible} [value] - The value to set for the field.
   * @returns {void}
   */
  setDefaults(r, t) {
    typeof r > "u" ? this.defaults = e(this.data) : typeof r == "string" ? this.defaults = { ...this.defaults, [r]: e(t) } : this.defaults = Object.assign(e(this.defaults), r);
  }
  /**
   * Apply a transformation to the form data before submission.
   * @param {(data: TForm) => object} callback - The transformation callback.
   * @returns {this} The form instance.
   */
  transform(r) {
    return this.transformCallback = r, this;
  }
  /**
   * Submit the form with the specified method and URL using Axios.
   * @param {Method} method - The HTTP method.
   * @param {string} url - The URL to submit to.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {Promise<void>} A promise that resolves when the form is submitted.
   */
  async submit(r, t, n) {
    var i;
    this.processing = !0, this.clearErrors();
    const c = this.transformCallback ? this.transformCallback(this.data) : this.data;
    this.cancelTokenSource = u.CancelToken.source();
    try {
      n != null && n.onBefore && n.onBefore();
      const a = S(this.data) ? T(this.data) : c, f = await this.axiosInstance({
        method: r,
        url: t,
        data: a,
        cancelToken: this.cancelTokenSource.token,
        headers: {
          "X-CSRF-TOKEN": ((i = document.querySelector('meta[name="csrf-token"]')) == null ? void 0 : i.content) || ""
        },
        onUploadProgress: (E) => {
          E.total && this.updateProgress(E, n);
        }
      });
      this.handleSuccess(f, n);
    } catch (a) {
      this.handleError(a, n);
    } finally {
      this.processing = !1, n != null && n.onFinish && n.onFinish();
    }
  }
  /**
   * Update the progress based on the Axios progress event.
   * @param {ProgressEvent} event - The Axios progress event.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {void}
   */
  updateProgress(r, t) {
    r.total && (this.progress = {
      total: r.total,
      loaded: r.loaded,
      percentage: Math.round(r.loaded / r.total * 100),
      bytes: r.loaded,
      lengthComputable: r.lengthComputable
    }, t != null && t.onProgress && this.progress && t.onProgress(this.progress));
  }
  /**
   * Handle the success response from the Axios request.
   * @param {AxiosResponse} response - The Axios response object.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {void}
   */
  handleSuccess(r, t) {
    this.wasSuccessful = !0, this.isDirty = !1, this.markRecentlySuccessful(), t != null && t.onSuccess && t.onSuccess(r);
  }
  /**
   * Handle an error response from an Axios request.
   * @param {unknown} error - The error object.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {void}
   */
  handleError(r, t) {
    var n;
    if (!u.isCancel(r)) {
      if (u.isAxiosError(r) && ((n = r.response) == null ? void 0 : n.status) === 422) {
        const c = r.response.data;
        this.errors = Object.entries(c.errors).reduce((i, [a, f]) => ({
          ...i,
          [a]: f
        }), {});
      } else
        this.errors = {
          formError: r instanceof Error ? r.message : "An unexpected error occurred"
        };
      t != null && t.onError && t.onError(this.errors);
    }
  }
  /**
   * Submit the form with a GET request.
   * @param {string} url - The URL to submit to.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {Promise<void>} A promise that resolves when the form is submitted.
   */
  get(r, t) {
    return this.submit("get", r, t);
  }
  /**
   * Submit the form with a POST request.
   * @param {string} url - The URL to submit to.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {Promise<void>} A promise that resolves when the form is submitted.
   */
  post(r, t) {
    return this.submit("post", r, t);
  }
  /**
   * Submit the form with a PUT request.
   * @param {string} url - The URL to submit to.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {Promise<void>} A promise that resolves when the form is submitted.
   */
  put(r, t) {
    return this.submit("put", r, t);
  }
  /**
   * Submit the form with a PATCH request.
   * @param {string} url - The URL to submit to.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {Promise<void>} A promise that resolves when the form is submitted.
   */
  patch(r, t) {
    return this.submit("patch", r, t);
  }
  /**
   * Submit the form with a DELETE request.
   * @param {string} url - The URL to submit to.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {Promise<void>} A promise that resolves when the form is submitted.
   */
  delete(r, t) {
    return this.submit("delete", r, t);
  }
  /**
   * Submit the form with an OPTIONS request.
   * @param {string} url - The URL to submit to.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {Promise<void>} A promise that resolves when the form is submitted.
   */
  options(r, t) {
    return this.submit("options", r, t);
  }
  /**
   * Submit the form with the specified method and URL using Axios, debounced.
   * @param {Method} method - The HTTP method.
   * @param {string} url - The URL to submit to.
   * @param {Partial<FormOptions<TForm>>} [options] - The form options.
   * @returns {void}
   */
  submitDebounced(r, t, n) {
    this.debouncedSubmit(r, t, n);
  }
  /**
   * Validate the form data against the defined rules.
   * @returns {Promise<boolean>} A promise that resolves with a boolean indicating if the form is valid.
   */
  async validate() {
    this.clearErrors();
    for (const [r, t] of Object.entries(this.rules)) {
      if (!t || t.length === 0)
        continue;
      const n = this.data[r];
      for (const c of t)
        if (!await c.validate(n)) {
          this.errors[r] = c.message;
          break;
        }
    }
    return Object.keys(this.errors).length === 0;
  }
  /**
   * Cancel a form submission in progress.
   * @returns {void}
   */
  cancel() {
    this.cancelTokenSource && this.cancelTokenSource.cancel("Form submission canceled."), this.processing = !1, this.progress = null;
  }
  /**
   * Clear all timeouts set by the form.
   * @returns {void}
   */
  clearTimeouts() {
    this.timeouts.forEach(clearTimeout), this.timeouts = [];
  }
  /**
   * Mark the form as recently successful for a short duration (e.g., 2 seconds).
   * @param {number} [timeout=2000] - The duration in milliseconds.
   * @returns {void}
   */
  markRecentlySuccessful(r = 2e3) {
    this.recentlySuccessful = !0;
    const t = window.setTimeout(() => {
      this.recentlySuccessful = !1;
    }, r);
    this.timeouts.push(t);
  }
  /**
   * Clear all timeouts and reset the form instance.
   * @returns {void}
   */
  dispose() {
    this.cancel(), this.clearErrors(), this.clearTimeouts();
    for (const r in this.data)
      delete this.data[r];
    for (const r in this.defaults)
      delete this.defaults[r];
    for (const r in this)
      delete this[r];
  }
}
function D(s) {
  return C(new I(s));
}
export {
  I as Form,
  D as useForm
};
